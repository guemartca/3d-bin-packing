!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("BinPacking",[],e):"object"==typeof exports?exports.BinPacking=e():t.BinPacking=e()}(this,(function(){return function(){"use strict";var t={d:function(e,i){for(var n in i)t.o(i,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:i[n]})},o:function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r:function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};function i(t){return i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i(t)}function n(t,e,n){return(e=function(t){var e=function(t){if("object"!=i(t)||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var n=e.call(t,"string");if("object"!=i(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==i(e)?e:e+""}(e))in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}t.r(e),t.d(e,{Bin:function(){return r},Item:function(){return f},Packer:function(){return y}});const h=t=>Math.round(t*10**5);function s(t,...e){}const o=function(t="binpackingjs"){return s.bind(void 0,t)}("3D:");class r{constructor(t,e,i,s,o){n(this,"name",""),n(this,"width",0),n(this,"height",0),n(this,"depth",0),n(this,"maxWeight",0),n(this,"items",[]),this.name=t,this.width=h(e),this.height=h(i),this.depth=h(s),this.maxWeight=h(o)}getName(){return this.name}getWidth(){return this.width}getHeight(){return this.height}getDepth(){return this.depth}getMaxWeight(){return this.maxWeight}getItems(){return this.items}getVolume(){return this.getWidth()*this.getHeight()*this.getDepth()}getPackedWeight(){return this.items.reduce(((t,e)=>t+e.getWeight()),0)}weighItem(t){const e=this.getMaxWeight();return!e||t.getWeight()+this.getPackedWeight()<=e}scoreRotation(t,e){t.rotationType=e;let i=t.getDimension();return this.getWidth()<i[0]||this.getHeight()<i[1]||this.getDepth()<i[2]?0:Math.pow(i[0]/this.getWidth(),2)+Math.pow(i[1]/this.getHeight(),2)+Math.pow(i[2]/this.getDepth(),2)}getBestRotationOrder(t){const e={};for(let i=0;i<t.allowedRotation.length;i++){const n=t.allowedRotation[i];e[n]=this.scoreRotation(t,n)}return Object.keys(e).sort(((t,i)=>e[i]-e[t])).map(Number)}putItem(t,e){const i=this;let n=!1;const h=this.getBestRotationOrder(t);t.position=e;for(let s=0;s<h.length;s++){t.rotationType=h[s];let r=t.getDimension();if(i.getWidth()<e[0]+r[0]||i.getHeight()<e[1]+r[1]||i.getDepth()<e[2]+r[2])n=!1;else{n=!0;for(let e=0;e<i.items.length;e++)if(i.items[e].intersect(t)){n=!1;break}n&&i.items.push(t)}if(o("try to putItem",n,"item",t.toString(),"box",i.toString()),n)break}return n}toString(){return`Bin:${this.name} (WxHxD = ${this.getWidth()}x${this.getHeight()}x${this.getDepth()}, MaxWg. = ${this.getMaxWeight()})`}}const g=0,a=1,u=2,l=3,m=4,p=5,c=[0,0,0],d={[g]:"RotationType_WHD (w,h,d)",[a]:"RotationType_HWD (h,w,d)",[u]:"RotationType_HDW (h,d,w)",[l]:"RotationType_DHW (d,h,w)",[m]:"RotationType_DWH (d,w,h)",[p]:"RotationType_WDH (w,d,h)"};class f{constructor(t,e,i,s,o,r){n(this,"name",""),n(this,"width",0),n(this,"height",0),n(this,"depth",0),n(this,"weight",0),n(this,"allowedRotation",[0,1,2,3,4,5]),n(this,"rotationType",0),n(this,"position",[]),this.name=t,this.width=h(e),this.height=h(i),this.depth=h(s),this.weight=h(o),this.allowedRotation=r||this.allowedRotation}getWidth(){return this.width}getHeight(){return this.height}getDepth(){return this.depth}getWeight(){return this.weight}getRotationType(){return this.rotationType}getAllowedRotation(){return this.allowedRotation}getRotationTypeString(){return d[this.getRotationType()]}getDimension(){let t;switch(this.rotationType){case 0:t=[this.getWidth(),this.getHeight(),this.getDepth()];break;case 1:t=[this.getHeight(),this.getWidth(),this.getDepth()];break;case 2:t=[this.getHeight(),this.getDepth(),this.getWidth()];break;case 3:t=[this.getDepth(),this.getHeight(),this.getWidth()];break;case 4:t=[this.getDepth(),this.getWidth(),this.getHeight()];break;case 5:t=[this.getWidth(),this.getDepth(),this.getHeight()]}return t}intersect(t){return b(this,t,0,1)&&b(this,t,1,2)&&b(this,t,0,2)}getVolume(){return this.getWidth()*this.getHeight()*this.getDepth()}toString(){return`Item:${this.name} (${this.getRotationTypeString()} = ${this.getDimension().join("x")}, Wg. = ${this.weight})`}}const b=(t,e,i,n)=>{let h,s,o,r,g,a,u,l;return h=t.getDimension(),s=e.getDimension(),o=t.position[i]+h[i]/2,r=t.position[n]+h[n]/2,g=e.position[i]+s[i]/2,a=e.position[n]+s[n]/2,u=Math.max(o,g)-Math.min(o,g),l=Math.max(r,a)-Math.min(r,a),u<(h[i]+s[i])/2&&l<(h[n]+s[n])/2};class y{constructor(){n(this,"bins",[]),n(this,"items",[]),n(this,"unfitItems",[])}addBin(t){this.bins.push(t)}addItem(t){this.items.push(t)}findFittedBin(t){for(let e=0;e<this.bins.length;e++){let i=this.bins[e];if(i.weighItem(t)&&i.putItem(t,c))return 1===i.items.length&&i.items[0]===t&&(i.items=[]),i}return null}getBiggerBinThan(t){let e=t.getVolume();for(let t=0;t<this.bins;t++){let i=this.bins[t];if(i.getVolume()>e)return i}return null}unfitItem(){0!==this.items.length&&(this.unfitItems.push(this.items[0]),this.items.splice(0,1))}packToBin(t,e){let i=null,n=[];if(!t.weighItem(e[0])||!t.putItem(e[0],c)){let i=this.getBiggerBinThan(t);return i?this.packToBin(i,e):this.items}for(let e=1;e<this.items.length;e++){let h=!1,s=this.items[e];if(t.weighItem(s))t:for(let e=0;e<3;e++)for(let i=0;i<t.items.length;i++){let n,o=t.items[i],r=o.getDimension();switch(e){case 0:n=[o.position[0]+r[0],o.position[1],o.position[2]];break;case 1:n=[o.position[0],o.position[1]+r[1],o.position[2]];break;case 2:n=[o.position[0],o.position[1],o.position[2]+r[2]]}if(t.putItem(s,n)){h=!0;break t}}if(!h){for(;null!==i;)if(i=this.getBiggerBinThan(t),i&&(i.items.push(s),0===this.packToBin(i,i.items).length)){t=i,h=!0;break}h||n.push(s)}}return n}pack(){for(this.bins.sort(((t,e)=>t.getVolume()-e.getVolume())),this.items.sort(((t,e)=>e.getVolume()-t.getVolume()));this.items.length>0;){let t=this.findFittedBin(this.items[0]);null!==t?this.items=this.packToBin(t,this.items):this.unfitItem()}return null}}return e}()}));